\chapter{Appendice}
\section{Funzione di codifica testuale}

La funzione di codifica testuale \`e contenuta nel file \textit{text\_md\_codec.cpp} presente nella directory \textit{mdc/src/codecs/text/}.

\begin{code}
void TextMDCodec::code(AbstractStream* stream, MDStream* md\_stream) const \{\\
	Uint32 stream\_size = stream->get\_data\_dim();\\
	Uint32 flow\_dimension = (stream\_size/m\_flows\_number)+1;\\
	Uint32 descriptors\_number = \\(Uint32)ceil(((double)flow\_dimension)/((double)m\_preferred\_payload\_size));\\
	Uint16 max\_payload\_size = (flow\_dimension/descriptors\_number)+1;\\
	md\_stream->init(stream->compute\_hash\_md5(), m\_flows\_number, descriptors\_number);\\
	for (Uint8 i=0; i<m\_flows\_number; i++) \{\\
		Uint64 offset = 0;\\
		for (Uint32 j=0; j<descriptors\_number; j++) \{\\
			if (stream\_size-(offset+i) > 0) \{\\
				Descriptor* descriptor = new Descriptor();\\
				descriptor->set\_stream\_id(md\_stream->get\_stream\_id());\\
				descriptor->set\_flow\_id(i);\\
				descriptor->set\_sequence\_number(j);\\
				descriptor->set\_codec\_name(string("text"));\\
				TextCodecParameters* tcp = new TextCodecParameters();\\
				descriptor->set\_codec\_parameter(tcp);\\
				MemDataChunk payload;\\
				Uint64 k;\\
				for (k=0; k<max\_payload\_size; k++)\\
					if (offset+i+k+m\_flows\_number < stream\_size)\\
						payload += \&stream->get\_data(offset+i+(k*m\_flows\_number), 1);\\
				offset += m\_flows\_number*k;\\
				descriptor->set\_payload(payload);\\
				md\_stream->set\_descriptor(descriptor);\\
			\}\\
		\}\\
	\}\\
\}\\
\end{code}

\begin{notabene}
La dicitura \textit{flow} \`e viene usata con il significato di ``\emph{Descrizioni}''. Tale variazione rispetto alla nomenclatura presente in letteratura \`e stata adottata al fine di evitare la possibile confusione dovuta alla somiglianza dei termini ``\emph{Descrizioni}'' e ``\emph{Descrittori}''. In seguito, quindi, la parola ``\emph{Flussi}'' \`e da intendersi con il significato di ``\emph{Descrizioni}''.
\end{notabene}

\section{Funzione di decodifica testuale}

La funzione di decodifica testuale \`e contenuta nel file \textit{text\_md\_codec.cpp} presente nella directory \textit{mdc/src/codecs/text/}.

\begin{code}
void TextMDCodec::decode(const MDStream* md\_stream, AbstractStream* stream) const \{\\
	if (md\_stream->is\_empty()) \\
		return;\\
	LOG\_INFO("Decoding...");\\
	MemDataChunk* dc = new MemDataChunk();\\
	vector<Uint8> taken\_stream;\\
	Uint8 flows\_number = md\_stream->get\_flows\_number();\\
	LOG\_INFO("Flows number: "$<<$flows\_number);\\
	Uint32 sequences\_number = md\_stream->get\_sequences\_number();\\
	LOG\_INFO("Sequences number: "$<<$sequences\_number);\\
	Uint64 max\_dimension = 0;\\
	for (Uint8 i=0; i<flows\_number; i++)\{
		Uint64 offset = 0;\\
		Uint16 payload\_size = 0;\\
		for (Uint32 j=0; j<sequences\_number; j++)\{
			Descriptor* descriptor = new Descriptor();\\
			if(!(descriptor->get\_codec\_name()=="text"))\\
			continue;\\
			if (md\_stream->get\_descriptor(i, j, descriptor))\{
				payload\_size = descriptor->get\_payload\_size();\\
				if (md\_stream->is\_valid(descriptor->get\_flow\_id(), descriptor->get\_sequence\_number()))\{
					(*dc) += (descriptor->get\_payload());\\
					taken\_stream.resize(flows\_number*sequences\_number*(payload\_size+1));\\
					Uint8 current\_received\_data;\\
					Uint64 k;\\
					for (k=0; k<payload\_size; k++) \{\\
						dc->extract\_head(current\_received\_data);\\
						if (current\_received\_data != 0) \{\\
							Uint64 locate\_position = offset+i+(k*flows\_number);\\
							taken\_stream[locate\_position] = current\_received\_data;\\
							if (locate\_position > max\_dimension)\\
								max\_dimension = locate\_position;\\
						\}\\
					\}\\
					offset += flows\_number*k;\\
				\}\\
			\}\\
			else\{\\
				Uint64 k;\\
				for (k=0; k<payload\_size; k++) \{\\
					Uint64 locate\_position = offset+i+(k*flows\_number);\\
					taken\_stream[locate\_position] = ' ';\\
				\}\\
				offset += flows\_number*k;\\
			\}\\
		\}\\
	\}\\
	MemDataChunk* taken\_dc = new MemDataChunk();\\
	Uint8* temp\_container = new Uint8[max\_dimension+1];\\
	for (Uint64 i=0; i<max\_dimension+1; i++)\\
		temp\_container[i] = taken\_stream[i];\\
	taken\_dc->append\_data(max\_dimension+1, temp\_container);\\
	stream->set\_data(*taken\_dc);\\
\}\\
\end{code}

\begin{notabene}
La dicitura \textit{flow} \`e viene usata con il significato di ``\emph{Descrizioni}''. Tale variazione rispetto alla nomenclatura presente in letteratura \`e stata adottata al fine di evitare la possibile confusione dovuta alla somiglianza dei termini ``\emph{Descrizioni}'' e ``\emph{Descrittori}''. In seguito, quindi, la parola ``\emph{Flussi}'' \`e da intendersi con il significato di ``\emph{Descrizioni}''.
\end{notabene}